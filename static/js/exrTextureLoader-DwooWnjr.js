import{C as Sn,c as rn,d as W}from"./index-BLcY3y1L.js";const an=4,X=4,sn=1,N=2,En=8,H=65536,j=H>>3,xn=16,C=14,k=(1<<xn)+1,V=1<<C,d=V-1,K=59,cn=63,vn=2+cn-K;var U;(function(n){n[n.NO_COMPRESSION=0]="NO_COMPRESSION",n[n.RLE_COMPRESSION=1]="RLE_COMPRESSION",n[n.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",n[n.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",n[n.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",n[n.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"})(U||(U={}));var q;(function(n){n[n.INCREASING_Y=0]="INCREASING_Y",n[n.DECREASING_Y=1]="DECREASING_Y"})(q||(q={}));const z=bn();function bn(){const n=new ArrayBuffer(4),t=new Float32Array(n),e=new Uint32Array(n),r=new Uint32Array(512),l=new Uint32Array(512);for(let i=0;i<256;++i){const a=i-127;a<-27?(r[i]=0,r[i|256]=32768,l[i]=24,l[i|256]=24):a<-14?(r[i]=1024>>-a-14,r[i|256]=1024>>-a-14|32768,l[i]=-a-1,l[i|256]=-a-1):a<=15?(r[i]=a+15<<10,r[i|256]=a+15<<10|32768,l[i]=13,l[i|256]=13):a<128?(r[i]=31744,r[i|256]=64512,l[i]=24,l[i|256]=24):(r[i]=31744,r[i|256]=64512,l[i]=13,l[i|256]=13)}const c=new Uint32Array(2048),s=new Uint32Array(64),o=new Uint32Array(64);for(let i=1;i<1024;++i){let a=i<<13,u=0;for(;(a&8388608)===0;)a<<=1,u-=8388608;a&=-8388609,u+=947912704,c[i]=a|u}for(let i=1024;i<2048;++i)c[i]=939524096+(i-1024<<13);for(let i=1;i<31;++i)s[i]=i<<23;s[31]=1199570944,s[32]=2147483648;for(let i=33;i<63;++i)s[i]=2147483648+(i-32<<23);s[63]=3347054592;for(let i=1;i<64;++i)i!==32&&(o[i]=1024);return{floatView:t,uint32View:e,baseTable:r,shiftTable:l,mantissaTable:c,exponentTable:s,offsetTable:o}}function $(n,t){const e=new Uint8Array(n);let r=0;for(;e[t.value+r]!=0;)r+=1;const l=new TextDecoder().decode(e.slice(t.value,t.value+r));return t.value=t.value+r+1,l}function P(n,t){const e=n.getInt32(t.value,!0);return t.value+=an,e}function R(n,t){const e=n.getUint32(t.value,!0);return t.value+=an,e}function Z(n,t){const e=n.getUint8(t.value);return t.value+=sn,e}function B(n,t){const e=n.getUint16(t.value,!0);return t.value+=N,e}function on(n,t){const e=n[t.value];return t.value+=sn,e}function gn(n,t){let e;return"getBigInt64"in DataView.prototype?e=Number(n.getBigInt64(t.value,!0)):e=n.getUint32(t.value+4,!0)+Number(n.getUint32(t.value,!0)<<32),t.value+=En,e}function b(n,t){const e=n.getFloat32(t.value,!0);return t.value+=X,e}function In(n,t){return On(B(n,t))}function On(n){const t=(n&31744)>>10,e=n&1023;return(n>>15?-1:1)*(t?t===31?e?NaN:1/0:Math.pow(2,t-15)*(1+e/1024):6103515625e-14*(e/1024))}function An(n){if(Math.abs(n)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");n=Sn(n,-65504,65504),z.floatView[0]=n;const t=z.uint32View[0],e=t>>23&511;return z.baseTable[e]+((t&8388607)>>z.shiftTable[e])}function Pn(n,t){return An(b(n,t))}function Un(n,t,e){const r=new TextDecoder().decode(new Uint8Array(n).slice(t.value,t.value+e));return t.value=t.value+e,r}function mn(n,t){const e=P(n,t),r=R(n,t);return[e,r]}function Rn(n,t){const e=R(n,t),r=R(n,t);return[e,r]}function Cn(n,t){const e=b(n,t),r=b(n,t);return[e,r]}function Tn(n,t){const e=b(n,t),r=b(n,t),l=b(n,t);return[e,r,l]}function _n(n,t,e){const r=t.value,l=[];for(;t.value<r+e-1;){const c=$(n.buffer,t),s=P(n,t),o=Z(n,t);t.value+=3;const i=P(n,t),a=P(n,t);l.push({name:c,pixelType:s,pLinear:o,xSampling:i,ySampling:a})}return t.value+=1,l}function Nn(n,t){const e=b(n,t),r=b(n,t),l=b(n,t),c=b(n,t),s=b(n,t),o=b(n,t),i=b(n,t),a=b(n,t);return{redX:e,redY:r,greenX:l,greenY:c,blueX:s,blueY:o,whiteX:i,whiteY:a}}function Mn(n,t){return Z(n,t)}function Dn(n,t){const e=P(n,t),r=P(n,t),l=P(n,t),c=P(n,t);return{xMin:e,yMin:r,xMax:l,yMax:c}}function kn(n,t){const e=Z(n,t);return q[e]}function Fn(n,t,e,r){switch(e){case"string":case"stringvector":case"iccProfile":return Un(n.buffer,t,r);case"chlist":return _n(n,t,r);case"chromaticities":return Nn(n,t);case"compression":return Mn(n,t);case"box2i":return Dn(n,t);case"lineOrder":return kn(n,t);case"float":return b(n,t);case"v2f":return Cn(n,t);case"v3f":return Tn(n,t);case"int":return P(n,t);case"rational":return mn(n,t);case"timecode":return Rn(n,t);case"preview":return t.value+=r,"skipped";default:t.value+=r;return}}function un(n){for(let t=1;t<n.length;t++){const e=n[t-1]+n[t]-128;n[t]=e}}function pn(n,t){let e=0,r=Math.floor((n.length+1)/2),l=0;const c=n.length-1;for(;!(l>c||(t[l++]=n[e++],l>c));)t[l++]=n[r++]}const Ln=20000630;function zn(n,t){if(n.getUint32(0,!0)!=Ln)throw new Error("Incorrect OpenEXR format");const e=n.getUint8(4),r=n.getUint8(5),l={singleTile:!!(r&2),longName:!!(r&4),deepFormat:!!(r&8),multiPart:!!(r&16)};t.value=8;const c={};let s=!0;for(;s;){const o=$(n.buffer,t);if(!o)s=!1;else{const i=$(n.buffer,t),a=R(n,t),u=Fn(n,t,i,a);u===void 0?rn.Warn(`Unknown header attribute type ${i}'.`):c[o]=u}}if((r&-5)!=0)throw new Error("Unsupported file format");return{version:e,spec:l,...c}}const fn=16,Hn=1<<fn-1,nn=(1<<fn)-1;function Bn(n,t){let e=0;for(let l=0;l<H;++l)(l==0||n[l>>3]&1<<(l&7))&&(t[e++]=l);const r=e-1;for(;e<H;)t[e++]=0;return r}function Zn(n){for(let t=0;t<V;t++)n[t]={},n[t].len=0,n[t].lit=0,n[t].p=null}function tn(n,t,e,r,l){for(;e<n;)t=t<<8|on(r,l),e+=8;return e-=n,{l:t>>e&(1<<n)-1,c:t,lc:e}}function J(n,t,e,r){return n=n<<8|on(e,r),t+=8,{c:n,lc:t}}function Y(n,t,e,r,l,c,s,o,i){if(n==t){if(r<8){const f=J(e,r,l,c);e=f.c,r=f.lc}r-=8;let a=e>>r;if(a=new Uint8Array([a])[0],o.value+a>i)return null;const u=s[o.value-1];for(;a-- >0;)s[o.value++]=u}else if(o.value<i)s[o.value++]=n;else return null;return{c:e,lc:r}}const D=new Array(59);function Gn(n){for(let e=0;e<=58;++e)D[e]=0;for(let e=0;e<k;++e)D[n[e]]+=1;let t=0;for(let e=58;e>0;--e){const r=t+D[e]>>1;D[e]=t,t=r}for(let e=0;e<k;++e){const r=n[e];r>0&&(n[e]=r|D[r]++<<6)}}function Wn(n,t,e,r,l,c){const s=t;let o=0,i=0;for(;r<=l;r++){if(s.value-t.value>e)return;let a=tn(6,o,i,n,s);const u=a.l;if(o=a.c,i=a.lc,c[r]=u,u==cn){if(s.value-t.value>e)throw new Error("Error in HufUnpackEncTable");a=tn(8,o,i,n,s);let f=a.l+vn;if(o=a.c,i=a.lc,r+f>l+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)c[r++]=0;r--}else if(u>=K){let f=u-K+2;if(r+f>l+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)c[r++]=0;r--}}Gn(c)}function hn(n){return n&63}function wn(n){return n>>6}function Yn(n,t,e,r){for(;t<=e;t++){const l=wn(n[t]),c=hn(n[t]);if(l>>c)throw new Error("Invalid table entry");if(c>C){const s=r[l>>c-C];if(s.len)throw new Error("Invalid table entry");if(s.lit++,s.p){const o=s.p;s.p=new Array(s.lit);for(let i=0;i<s.lit-1;++i)s.p[i]=o[i]}else s.p=new Array(1);s.p[s.lit-1]=t}else if(c){let s=0;for(let o=1<<C-c;o>0;o--){const i=r[(l<<C-c)+s];if(i.len||i.p)throw new Error("Invalid table entry");i.len=c,i.lit=t,s++}}}return!0}function Xn(n,t,e,r,l,c,s,o,i){let a=0,u=0;const f=s,x=Math.trunc(r.value+(l+7)/8);for(;r.value<x;){let p=J(a,u,e,r);for(a=p.c,u=p.lc;u>=C;){const w=a>>u-C&d,y=t[w];if(y.len){u-=y.len;const h=Y(y.lit,c,a,u,e,r,o,i,f);h&&(a=h.c,u=h.lc)}else{if(!y.p)throw new Error("hufDecode issues");let h;for(h=0;h<y.lit;h++){const v=hn(n[y.p[h]]);for(;u<v&&r.value<x;)p=J(a,u,e,r),a=p.c,u=p.lc;if(u>=v&&wn(n[y.p[h]])==(a>>u-v&(1<<v)-1)){u-=v;const A=Y(y.p[h],c,a,u,e,r,o,i,f);A&&(a=A.c,u=A.lc);break}}if(h==y.lit)throw new Error("HufDecode issues")}}}const I=8-l&7;for(a>>=I,u-=I;u>0;){const p=t[a<<C-u&d];if(p.len){u-=p.len;const w=Y(p.lit,c,a,u,e,r,o,i,f);w&&(a=w.c,u=w.lc)}else throw new Error("HufDecode issues")}return!0}function Kn(n,t,e,r,l,c){const s={value:0},o=e.value,i=R(t,e),a=R(t,e);e.value+=4;const u=R(t,e);if(e.value+=4,i<0||i>=k||a<0||a>=k)throw new Error("Wrong HUF_ENCSIZE");const f=new Array(k),x=new Array(V);Zn(x);const I=r-(e.value-o);if(Wn(n,e,I,i,a,f),u>8*(r-(e.value-o)))throw new Error("Wrong hufUncompress");Yn(f,i,a,x),Xn(f,x,n,e,u,a,c,l,s)}function Q(n){return n&65535}function en(n){const t=Q(n);return t>32767?t-65536:t}function T(n,t){const e=en(n),l=en(t),c=e+(l&1)+(l>>1),s=c,o=c-l;return{a:s,b:o}}function _(n,t){const e=Q(n),r=Q(t),l=e-(r>>1)&nn;return{a:r+l-Hn&nn,b:l}}function qn(n,t,e,r,l,c,s){const o=s<16384,i=e>l?l:e;let a=1,u,f;for(;a<=i;)a<<=1;for(a>>=1,u=a,a>>=1;a>=1;){f=0;const x=f+c*(l-u),I=c*a,p=c*u,w=r*a,y=r*u;let h,v,A,F;for(;f<=x;f+=p){let E=f;const G=f+r*(e-u);for(;E<=G;E+=y){const O=E+w,g=E+I,L=g+w;if(o){let S=T(n[E+t],n[g+t]);h=S.a,A=S.b,S=T(n[O+t],n[L+t]),v=S.a,F=S.b,S=T(h,v),n[E+t]=S.a,n[O+t]=S.b,S=T(A,F),n[g+t]=S.a,n[L+t]=S.b}else{let S=_(n[E+t],n[g+t]);h=S.a,A=S.b,S=_(n[O+t],n[L+t]),v=S.a,F=S.b,S=_(h,v),n[E+t]=S.a,n[O+t]=S.b,S=_(A,F),n[g+t]=S.a,n[L+t]=S.b}}if(e&a){const O=E+I;let g;o?g=T(n[E+t],n[O+t]):g=_(n[E+t],n[O+t]),h=g.a,n[O+t]=g.b,n[E+t]=h}}if(l&a){let E=f;const G=f+r*(e-u);for(;E<=G;E+=y){const O=E+w;let g;o?g=T(n[E+t],n[O+t]):g=_(n[E+t],n[O+t]),h=g.a,n[O+t]=g.b,n[E+t]=h}}u=a,a>>=1}return f}function $n(n,t,e){for(let r=0;r<e;++r)t[r]=n[t[r]]}function Jn(n){let t=n.byteLength;const e=[];let r=0;const l=new DataView(n);for(;t>0;){const c=l.getInt8(r++);if(c<0){const s=-c;t-=s+1;for(let o=0;o<s;o++)e.push(l.getUint8(r++))}else{const s=c;t-=2;const o=l.getUint8(r++);for(let i=0;i<s+1;i++)e.push(o)}}return e}function yn(n){return new DataView(n.array.buffer,n.offset.value,n.size)}function Qn(n){const t=n.viewer.buffer.slice(n.offset.value,n.offset.value+n.size),e=new Uint8Array(Jn(t)),r=new Uint8Array(e.length);return un(e),pn(e,r),new DataView(r.buffer)}function ln(n){const t=n.array.slice(n.offset.value,n.offset.value+n.size),e=fflate.unzlibSync(t),r=new Uint8Array(e.length);return un(e),pn(e,r),new DataView(r.buffer)}function Vn(n){const t=n.array.slice(n.offset.value,n.offset.value+n.size),e=fflate.unzlibSync(t),r=n.lines*n.channels*n.width,l=n.type==1?new Uint16Array(r):new Uint32Array(r);let c=0,s=0;const o=new Array(4);for(let i=0;i<n.lines;i++)for(let a=0;a<n.channels;a++){let u=0;switch(n.type){case 1:o[0]=c,o[1]=o[0]+n.width,c=o[1]+n.width;for(let f=0;f<n.width;++f){const x=e[o[0]++]<<8|e[o[1]++];u+=x,l[s]=u,s++}break;case 2:o[0]=c,o[1]=o[0]+n.width,o[2]=o[1]+n.width,c=o[2]+n.width;for(let f=0;f<n.width;++f){const x=e[o[0]++]<<24|e[o[1]++]<<16|e[o[2]++]<<8;u+=x,l[s]=u,s++}break}}return new DataView(l.buffer)}function jn(n){const t=n.viewer,e={value:n.offset.value},r=new Uint16Array(n.width*n.scanlineBlockSize*(n.channels*n.type)),l=new Uint8Array(j);let c=0;const s=new Array(n.channels);for(let p=0;p<n.channels;p++)s[p]={},s[p].start=c,s[p].end=s[p].start,s[p].nx=n.width,s[p].ny=n.lines,s[p].size=n.type,c+=s[p].nx*s[p].ny*s[p].size;const o=B(t,e),i=B(t,e);if(i>=j)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(o<=i)for(let p=0;p<i-o+1;p++)l[p+o]=Z(t,e);const a=new Uint16Array(H),u=Bn(l,a),f=R(t,e);Kn(n.array,t,e,f,r,c);for(let p=0;p<n.channels;++p){const w=s[p];for(let y=0;y<s[p].size;++y)qn(r,w.start+y,w.nx,w.size,w.ny,w.nx*w.size,u)}$n(a,r,c);let x=0;const I=new Uint8Array(r.buffer.byteLength);for(let p=0;p<n.lines;p++)for(let w=0;w<n.channels;w++){const y=s[w],h=y.nx*y.size,v=new Uint8Array(r.buffer,y.end*N,h*N);I.set(v,x),x+=h*N,y.end+=h}return new DataView(I.buffer)}var m;(function(n){n[n.Float=0]="Float",n[n.HalfFloat=1]="HalfFloat"})(m||(m={}));class M{}M.DefaultOutputType=m.HalfFloat;M.FFLATEUrl="https://unpkg.com/fflate@0.8.2";async function dn(n,t,e,r){const l={size:0,viewer:t,array:new Uint8Array(t.buffer),offset:e,width:n.dataWindow.xMax-n.dataWindow.xMin+1,height:n.dataWindow.yMax-n.dataWindow.yMin+1,channels:n.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(n.compression){case U.NO_COMPRESSION:l.lines=1,l.uncompress=yn;break;case U.RLE_COMPRESSION:l.lines=1,l.uncompress=Qn;break;case U.ZIPS_COMPRESSION:l.lines=1,l.uncompress=ln,await W.LoadScriptAsync(M.FFLATEUrl);break;case U.ZIP_COMPRESSION:l.lines=16,l.uncompress=ln,await W.LoadScriptAsync(M.FFLATEUrl);break;case U.PIZ_COMPRESSION:l.lines=32,l.uncompress=jn;break;case U.PXR24_COMPRESSION:l.lines=16,l.uncompress=Vn,await W.LoadScriptAsync(M.FFLATEUrl);break;default:throw new Error(U[n.compression]+" is unsupported")}l.scanlineBlockSize=l.lines;const c={};for(const a of n.channels)switch(a.name){case"R":case"G":case"B":case"A":c[a.name]=!0,l.type=a.pixelType;break;case"Y":c[a.name]=!0,l.type=a.pixelType;break}let s=!1;if(c.R&&c.G&&c.B&&c.A)l.outputChannels=4,l.decodeChannels={R:0,G:1,B:2,A:3};else if(c.R&&c.G&&c.B)s=!0,l.outputChannels=4,l.decodeChannels={R:0,G:1,B:2,A:3};else if(c.R&&c.G)l.outputChannels=2,l.decodeChannels={R:0,G:1};else if(c.R)l.outputChannels=1,l.decodeChannels={R:0};else if(c.Y)l.outputChannels=1,l.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(l.type===1)switch(r){case m.Float:l.getter=In,l.inputSize=N;break;case m.HalfFloat:l.getter=B,l.inputSize=N;break}else if(l.type===2)switch(r){case m.Float:l.getter=b,l.inputSize=X;break;case m.HalfFloat:l.getter=Pn,l.inputSize=X}else throw new Error("Unsupported pixelType "+l.type+" for "+n.compression);l.blockCount=l.height/l.scanlineBlockSize;for(let a=0;a<l.blockCount;a++)gn(t,e);const o=l.width*l.height*l.outputChannels;switch(r){case m.Float:l.byteArray=new Float32Array(o),l.textureType=1,s&&l.byteArray.fill(1,0,o);break;case m.HalfFloat:l.byteArray=new Uint16Array(o),l.textureType=2,s&&l.byteArray.fill(15360,0,o);break;default:throw new Error("Unsupported type: "+r)}let i=0;for(const a of n.channels)l.decodeChannels[a.name]!==void 0&&(l.channelLineOffsets[a.name]=i*l.width),i+=a.pixelType*2;return l.bytesPerLine=l.width*i,l.outLineWidth=l.width*l.outputChannels,n.lineOrder==="INCREASING_Y"?l.scanOrder=a=>a:l.scanOrder=a=>l.height-1-a,l.outputChannels==4?(l.format=5,l.linearSpace=!0):(l.format=6,l.linearSpace=!1),l}function nt(n,t,e,r){const l={value:0};for(let c=0;c<n.height/n.scanlineBlockSize;c++){const s=P(e,r)-t.dataWindow.yMin;n.size=R(e,r),n.lines=s+n.scanlineBlockSize>n.height?n.height-s:n.scanlineBlockSize;const i=n.size<n.lines*n.bytesPerLine&&n.uncompress?n.uncompress(n):yn(n);r.value+=n.size;for(let a=0;a<n.scanlineBlockSize;a++){const u=c*n.scanlineBlockSize,f=a+n.scanOrder(u);if(f>=n.height)continue;const x=a*n.bytesPerLine,I=(n.height-1-f)*n.outLineWidth;for(let p=0;p<n.channels;p++){const w=t.channels[p].name,y=n.channelLineOffsets[w],h=n.decodeChannels[w];if(h!==void 0){l.value=x+y;for(let v=0;v<n.width;v++){const A=I+v*n.outputChannels+h;n.byteArray&&(n.byteArray[A]=n.getter(i,l))}}}}}}class et{constructor(){this.supportCascades=!1}loadCubeData(t,e,r,l,c){throw".exr not supported in Cube."}loadData(t,e,r){const l=new DataView(t.buffer),c={value:0},s=zn(l,c);dn(s,l,c,M.DefaultOutputType).then(o=>{nt(o,s,l,c);const i=s.dataWindow.xMax-s.dataWindow.xMin+1,a=s.dataWindow.yMax-s.dataWindow.yMin+1;r(i,a,e.generateMipMaps,!1,()=>{const u=e.getEngine();e.format=s.format,e.type=o.textureType,e.invertY=!1,e._gammaSpace=!s.linearSpace,o.byteArray&&u._uploadDataToTextureDirectly(e,o.byteArray,0,0,void 0,!0)})}).catch(o=>{rn.Error("Failed to load EXR texture: ",o)})}}export{et as _ExrTextureLoader};
