import{A as T,R as At,b as yt,I as pt,_ as Ft,c as H,F as U,T as M,C as w}from"./index-BLcY3y1L.js";import{C as Ct}from"./cubemapToSphericalPolynomial-BFSiXulV.js";function dt(C){const n=C.split("?")[0],e=n.lastIndexOf(".");return e>-1?n.substring(e).toLowerCase():""}T.prototype._partialLoadFile=function(C,n,e,r,o=null){const i=t=>{e[n]=t,e._internalCount++,e._internalCount===6&&r(e)},u=(t,l)=>{o&&t&&o(t.status+" "+t.statusText,l)};this._loadFile(C,i,void 0,void 0,!0,u)};T.prototype._cascadeLoadFiles=function(C,n,e,r=null){const o=[];o._internalCount=0;for(let i=0;i<6;i++)this._partialLoadFile(e[i],i,o,n,r)};T.prototype._cascadeLoadImgs=function(C,n,e,r,o=null,i){const u=[];u._internalCount=0;for(let t=0;t<6;t++)this._partialLoadImg(r[t],t,u,C,n,e,o,i)};T.prototype._partialLoadImg=function(C,n,e,r,o,i,u=null,t){const l=At();yt(C,c=>{e[n]=c,e._internalCount++,r&&r.removePendingData(l),e._internalCount===6&&i&&i(o,e)},(c,f)=>{r&&r.removePendingData(l),u&&u(c,f)},r?r.offlineProvider:null,t),r&&r.addPendingData(l)};T.prototype.createCubeTextureBase=function(C,n,e,r,o=null,i=null,u,t=null,l=!1,a=0,s=0,c=null,f=null,G=null,y=!1,p=null){const A=c||new pt(this,7);A.isCube=!0,A.url=C,A.generateMipMaps=!r,A._lodGenerationScale=a,A._lodGenerationOffset=s,A._useSRGBBuffer=!!y&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!r),A!==c&&(A.label=C.substring(0,60)),this._doNotHandleContextLost||(A._extension=t,A._files=e,A._buffer=p);const _=C;this._transformTextureUrl&&!c&&(C=this._transformTextureUrl(C));const B=t??dt(C),P=Ft(B),g=(h,b)=>{C===_?i&&h&&i(h.status+" "+h.statusText,b):(H.Warn(`Failed to load ${C}, falling back to the ${_}`),this.createCubeTextureBase(_,n,e,!!r,o,i,u,t,l,a,s,A,f,G,y,p))};if(P)P.then(h=>{const b=d=>{f&&f(A,d),h.loadCubeData(d,A,l,o,i)};p?b(p):e&&e.length===6?h.supportCascades?this._cascadeLoadFiles(n,d=>b(d.map(I=>new Uint8Array(I))),e,i):i?i("Textures type does not support cascades."):H.Warn("Texture loader does not support cascades."):this._loadFile(C,d=>b(new Uint8Array(d)),void 0,void 0,!0,g)});else{if(!e||e.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(n,A,(h,b)=>{G&&G(h,b)},e,i)}return this._internalTexturesCache.push(A),A};const _t=542327876,Q=131072,V=512,Y=4,Z=64,S=131072;function X(C){return C.charCodeAt(0)+(C.charCodeAt(1)<<8)+(C.charCodeAt(2)<<16)+(C.charCodeAt(3)<<24)}function Gt(C){return String.fromCharCode(C&255,C>>8&255,C>>16&255,C>>24&255)}const q=X("DXT1"),tt=X("DXT3"),et=X("DXT5"),z=X("DX10"),rt=113,at=116,nt=2,st=10,ht=88,E=31,mt=0,bt=1,ot=2,ft=3,$=4,it=7,j=20,lt=21,xt=22,Bt=23,Rt=24,Ot=25,Ut=26,wt=28,gt=32;class F{static GetDDSInfo(n){const e=new Int32Array(n.buffer,n.byteOffset,E),r=new Int32Array(n.buffer,n.byteOffset,E+4);let o=1;e[ot]&Q&&(o=Math.max(1,e[it]));const i=e[lt],u=i===z?r[gt]:0;let t=0;switch(i){case rt:t=2;break;case at:t=1;break;case z:if(u===st){t=2;break}if(u===nt){t=1;break}}return{width:e[$],height:e[ft],mipmapCount:o,isFourCC:(e[j]&Y)===Y,isRGB:(e[j]&Z)===Z,isLuminance:(e[j]&S)===S,isCube:(e[wt]&V)===V,isCompressed:i===q||i===tt||i===et,dxgiFormat:u,textureType:t}}static _GetHalfFloatAsFloatRGBAArrayBuffer(n,e,r,o,i,u){const t=new Float32Array(o),l=new Uint16Array(i,r);let a=0;for(let s=0;s<e;s++)for(let c=0;c<n;c++){const f=(c+s*n)*4;t[a]=U(l[f]),t[a+1]=U(l[f+1]),t[a+2]=U(l[f+2]),F.StoreLODInAlphaChannel?t[a+3]=u:t[a+3]=U(l[f+3]),a+=4}return t}static _GetHalfFloatRGBAArrayBuffer(n,e,r,o,i,u){if(F.StoreLODInAlphaChannel){const t=new Uint16Array(o),l=new Uint16Array(i,r);let a=0;for(let s=0;s<e;s++)for(let c=0;c<n;c++){const f=(c+s*n)*4;t[a]=l[f],t[a+1]=l[f+1],t[a+2]=l[f+2],t[a+3]=M(u),a+=4}return t}return new Uint16Array(i,r,o)}static _GetFloatRGBAArrayBuffer(n,e,r,o,i,u){if(F.StoreLODInAlphaChannel){const t=new Float32Array(o),l=new Float32Array(i,r);let a=0;for(let s=0;s<e;s++)for(let c=0;c<n;c++){const f=(c+s*n)*4;t[a]=l[f],t[a+1]=l[f+1],t[a+2]=l[f+2],t[a+3]=u,a+=4}return t}return new Float32Array(i,r,o)}static _GetFloatAsHalfFloatRGBAArrayBuffer(n,e,r,o,i,u){const t=new Uint16Array(o),l=new Float32Array(i,r);let a=0;for(let s=0;s<e;s++)for(let c=0;c<n;c++)t[a]=M(l[a]),t[a+1]=M(l[a+1]),t[a+2]=M(l[a+2]),F.StoreLODInAlphaChannel?t[a+3]=M(u):t[a+3]=M(l[a+3]),a+=4;return t}static _GetFloatAsUIntRGBAArrayBuffer(n,e,r,o,i,u){const t=new Uint8Array(o),l=new Float32Array(i,r);let a=0;for(let s=0;s<e;s++)for(let c=0;c<n;c++){const f=(c+s*n)*4;t[a]=w(l[f])*255,t[a+1]=w(l[f+1])*255,t[a+2]=w(l[f+2])*255,F.StoreLODInAlphaChannel?t[a+3]=u:t[a+3]=w(l[f+3])*255,a+=4}return t}static _GetHalfFloatAsUIntRGBAArrayBuffer(n,e,r,o,i,u){const t=new Uint8Array(o),l=new Uint16Array(i,r);let a=0;for(let s=0;s<e;s++)for(let c=0;c<n;c++){const f=(c+s*n)*4;t[a]=w(U(l[f]))*255,t[a+1]=w(U(l[f+1]))*255,t[a+2]=w(U(l[f+2]))*255,F.StoreLODInAlphaChannel?t[a+3]=u:t[a+3]=w(U(l[f+3]))*255,a+=4}return t}static _GetRGBAArrayBuffer(n,e,r,o,i,u,t,l,a){const s=new Uint8Array(o),c=new Uint8Array(i,r);let f=0;for(let G=0;G<e;G++)for(let y=0;y<n;y++){const p=(y+G*n)*4;s[f]=c[p+u],s[f+1]=c[p+t],s[f+2]=c[p+l],s[f+3]=c[p+a],f+=4}return s}static _ExtractLongWordOrder(n){return n===0||n===255||n===-16777216?0:1+F._ExtractLongWordOrder(n>>8)}static _GetRGBArrayBuffer(n,e,r,o,i,u,t,l){const a=new Uint8Array(o),s=new Uint8Array(i,r);let c=0;for(let f=0;f<e;f++)for(let G=0;G<n;G++){const y=(G+f*n)*3;a[c]=s[y+u],a[c+1]=s[y+t],a[c+2]=s[y+l],c+=3}return a}static _GetLuminanceArrayBuffer(n,e,r,o,i){const u=new Uint8Array(o),t=new Uint8Array(i,r);let l=0;for(let a=0;a<e;a++)for(let s=0;s<n;s++){const c=s+a*n;u[l]=t[c],l++}return u}static UploadDDSLevels(n,e,r,o,i,u,t=-1,l,a=!0){let s=null;o.sphericalPolynomial&&(s=[]);const c=!!n.getCaps().s3tc;e.generateMipMaps=i;const f=new Int32Array(r.buffer,r.byteOffset,E);let G,y,p,A=0,_,B,P,g,h=0,b=1;if(f[mt]!==_t){H.Error("Invalid magic number in DDS header");return}if(!o.isFourCC&&!o.isRGB&&!o.isLuminance){H.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");return}if(o.isCompressed&&!c){H.Error("Compressed textures are not supported on this platform.");return}let d=f[xt];_=f[bt]+4;let I=!1;if(o.isFourCC)switch(G=f[lt],G){case q:b=8,h=33777;break;case tt:b=16,h=33778;break;case et:b=16,h=33779;break;case rt:I=!0,d=64;break;case at:I=!0,d=128;break;case z:{_+=5*4;let x=!1;switch(o.dxgiFormat){case st:I=!0,d=64,x=!0;break;case nt:I=!0,d=128,x=!0;break;case ht:o.isRGB=!0,o.isFourCC=!1,d=32,x=!0;break}if(x)break}default:H.Error(["Unsupported FourCC code:",Gt(G)]);return}const v=F._ExtractLongWordOrder(f[Bt]),J=F._ExtractLongWordOrder(f[Rt]),K=F._ExtractLongWordOrder(f[Ot]),ct=F._ExtractLongWordOrder(f[Ut]);I&&(h=n._getRGBABufferInternalSizedFormat(o.textureType)),P=1,f[ot]&Q&&i!==!1&&(P=Math.max(1,f[it]));const ut=l||0,k=n.getCaps();for(let x=ut;x<u;x++){for(y=f[$],p=f[ft],g=0;g<P;++g){if(t===-1||t===g){const m=t===-1?g:0;if(!o.isCompressed&&o.isFourCC){e.format=5,A=y*p*4;let R=null;if(n._badOS||n._badDesktopOS||!k.textureHalfFloat&&!k.textureFloat)d===128?(R=F._GetFloatAsUIntRGBAArrayBuffer(y,p,r.byteOffset+_,A,r.buffer,m),s&&m==0&&s.push(F._GetFloatRGBAArrayBuffer(y,p,r.byteOffset+_,A,r.buffer,m))):d===64&&(R=F._GetHalfFloatAsUIntRGBAArrayBuffer(y,p,r.byteOffset+_,A,r.buffer,m),s&&m==0&&s.push(F._GetHalfFloatAsFloatRGBAArrayBuffer(y,p,r.byteOffset+_,A,r.buffer,m))),e.type=0;else{const D=k.textureFloat&&(a&&k.textureFloatLinearFiltering||!a),W=k.textureHalfFloat&&(a&&k.textureHalfFloatLinearFiltering||!a),N=(d===128||d===64&&!W)&&D?1:(d===64||d===128&&!D)&&W?2:0;let L,O=null;switch(d){case 128:{switch(N){case 1:L=F._GetFloatRGBAArrayBuffer,O=null;break;case 2:L=F._GetFloatAsHalfFloatRGBAArrayBuffer,O=F._GetFloatRGBAArrayBuffer;break;case 0:L=F._GetFloatAsUIntRGBAArrayBuffer,O=F._GetFloatRGBAArrayBuffer;break}break}default:{switch(N){case 1:L=F._GetHalfFloatAsFloatRGBAArrayBuffer,O=null;break;case 2:L=F._GetHalfFloatRGBAArrayBuffer,O=F._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:L=F._GetHalfFloatAsUIntRGBAArrayBuffer,O=F._GetHalfFloatAsFloatRGBAArrayBuffer;break}break}}e.type=N,R=L(y,p,r.byteOffset+_,A,r.buffer,m),s&&m==0&&s.push(O?O(y,p,r.byteOffset+_,A,r.buffer,m):R)}R&&n._uploadDataToTextureDirectly(e,R,x,m)}else if(o.isRGB)e.type=0,d===24?(e.format=4,A=y*p*3,B=F._GetRGBArrayBuffer(y,p,r.byteOffset+_,A,r.buffer,v,J,K),n._uploadDataToTextureDirectly(e,B,x,m)):(e.format=5,A=y*p*4,B=F._GetRGBAArrayBuffer(y,p,r.byteOffset+_,A,r.buffer,v,J,K,ct),n._uploadDataToTextureDirectly(e,B,x,m));else if(o.isLuminance){const R=n._getUnpackAlignement(),D=y;A=Math.floor((y+R-1)/R)*R*(p-1)+D,B=F._GetLuminanceArrayBuffer(y,p,r.byteOffset+_,A,r.buffer),e.format=1,e.type=0,n._uploadDataToTextureDirectly(e,B,x,m)}else A=Math.max(4,y)/4*Math.max(4,p)/4*b,B=new Uint8Array(r.buffer,r.byteOffset+_,A),e.type=0,n._uploadCompressedDataToTextureDirectly(e,h,y,p,B,x,m)}_+=d?y*p*(d/8):A,y*=.5,p*=.5,y=Math.max(1,y),p=Math.max(1,p)}if(l!==void 0)break}s&&s.length>0?o.sphericalPolynomial=Ct.ConvertCubeMapToSphericalPolynomial({size:f[$],right:s[0],left:s[1],up:s[2],down:s[3],front:s[4],back:s[5],format:5,type:1,gammaSpace:!1}):o.sphericalPolynomial=void 0}}F.StoreLODInAlphaChannel=!1;export{F as DDSTools};
